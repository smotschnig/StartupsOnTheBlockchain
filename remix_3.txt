pragma solidity ^0.4.2;

contract Factory {
    address[] public deployedProjects;
    address[] public deployedProfiles;
    mapping(address => ProjectInitializer) public projectMap;
    
    /* Bisschen uncool mit doppelter Ausführung (siehe contract ProjectInstance), aber sonst keine besser Möglichkeit gefunden die Startseite ordentlich aufzulisten */
    struct ProjectInitializer {
        string startup;
        string title;
        uint wage;
    }

    function createProject(string startup, string title, uint deadline, string description, uint wage) public {
        address newProject = new ProjectInstance(startup, title, deadline, description, wage, now, msg.sender);
        
        ProjectInitializer memory newProjectInitializer = ProjectInitializer({
           startup: startup,
           title: title,
           wage: wage
        });
        
        projectMap[newProject] = newProjectInitializer;
        deployedProjects.push(newProject);
    }
    
    function getDeployedProjects() public view returns (address[]) {
        return deployedProjects;
    }
    
    function createProfile(string fName, string lName, uint birthDate, string education, string experience, string skills) public {
        address newProfile = new ProfileInstance(fName, lName, birthDate, education, experience, skills, now, msg.sender);
        deployedProfiles.push(newProfile);
    }
    
    function getDeployedProfiles() public view returns (address[]) {
        return (
            deployedProfiles
        );
    }

}

contract ProjectInstance {
    address public manager;
    mapping(address => bool) public requester;
    address[] public requesterList;
    uint public requesterCount;
    Project public project;
    
    struct Project {
        string startup;
        string title;
        uint deadline;
        string description;
        uint wage;
        uint date;
        bool finalize;
        mapping(address => bool) requests;
    }
    
    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    constructor(string _startup, string _title, uint _deadline, string _description, uint _wage, uint _date, address _manager) public {
        manager = _manager;
        Project memory newProject = Project({
           startup: _startup,
           title: _title,
           deadline: _deadline,
           description: _description,
           wage: _wage,
           date: _date,
           finalize: false
        });
        project = newProject;
    }

    function setRequest() public {
        Project storage storedProject = project;
        
        require(msg.sender != manager);
        require(!requester[msg.sender]);
        requester[msg.sender] = true;

        storedProject.requests[msg.sender] = true;
        requesterCount++;
        
        requesterList.push(msg.sender);
        
    }
    
    function chooseFreelancer() {
        
    }
    
    function finalizeProject() public {
        Project storage storedProject = project;
        
        storedProject.finalize = true;
    }
    
    function getRequesterList() public view returns (address[]) {
        return requesterList;
    }

}

contract ProfileInstance {
    address public manager;
    ProfileInstructor public profile;
    mapping (address => ProfileInstructor) instructors;
    uint public rating;
        
    struct ProfileInstructor {
        string fName;
        string lName;
        uint birthDate;
        string education;
        string experience;
        string skills;
        uint date;
    }
    
    modifier restricted {
        require(msg.sender == manager);
        _;
    }
    
    event instructorInfo(
        string fName,
        string lName,
        uint birthDate,
        string education,
        string experience,
        string skills
    ); 
    
    constructor(string _fName, string _lName, uint _birthDate, string _education, string _experience, string _skills, uint _date, address _manager) public {
        manager = _manager;
        
        ProfileInstructor memory newProfileInstructor = ProfileInstructor({
            fName: _fName, 
            lName: _lName, 
            birthDate: _birthDate, 
            education: _education, 
            experience: _experience, 
            skills: _skills, 
            date: _date
        });
        profile = newProfileInstructor;
    }
    
    function setInstructor(string _fName, string _lName, uint _birthDate, string _education, string _experience, string _skills) restricted public {
        ProfileInstructor memory newProfileInstructor = ProfileInstructor({
            fName: _fName, 
            lName: _lName, 
            birthDate: _birthDate, 
            education: _education, 
            experience: _experience, 
            skills: _skills, 
            date: now
        });
        profile = newProfileInstructor;
    }
}